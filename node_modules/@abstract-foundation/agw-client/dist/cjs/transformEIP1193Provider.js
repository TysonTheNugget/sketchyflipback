"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformEIP1193Provider = transformEIP1193Provider;
const viem_1 = require("viem");
const accounts_1 = require("viem/accounts");
const abstractClient_js_1 = require("./abstractClient.js");
const eip5792_js_1 = require("./eip5792.js");
const index_js_1 = require("./exports/index.js");
const utils_js_1 = require("./utils.js");
async function getAgwAddressFromInitialSigner(chain, transport, signer) {
    const publicClient = (0, viem_1.createPublicClient)({
        chain,
        transport,
    });
    return await (0, utils_js_1.getSmartAccountAddressFromInitialSigner)(signer, publicClient);
}
async function getAgwSigner(provider, method = 'eth_accounts') {
    const accounts = await provider.request({ method });
    return accounts?.[0];
}
async function getAgwClient(account, chain, transport, isPrivyCrossApp, overrideTransport, customPaymasterHandler) {
    const wallet = (0, viem_1.createWalletClient)({
        account,
        transport,
    });
    const signer = (0, accounts_1.toAccount)({
        address: account,
        signMessage: wallet.signMessage,
        signTransaction: wallet.signTransaction,
        signTypedData: wallet.signTypedData,
    });
    const abstractClient = await (0, abstractClient_js_1.createAbstractClient)({
        chain,
        signer,
        transport,
        isPrivyCrossApp,
        publicTransport: overrideTransport,
        customPaymasterHandler,
    });
    return abstractClient;
}
function transformEIP1193Provider(options) {
    const { provider, chain, transport: overrideTransport, isPrivyCrossApp = false, customPaymasterHandler, } = options;
    const transport = (0, viem_1.custom)(provider);
    const handler = async (e) => {
        const { method, params } = e;
        switch (method) {
            case 'eth_requestAccounts': {
                const signer = await getAgwSigner(provider, method);
                if (!signer) {
                    return [];
                }
                const smartAccount = await getAgwAddressFromInitialSigner(chain, transport, signer);
                return [smartAccount, signer];
            }
            case 'eth_accounts': {
                const signer = await getAgwSigner(provider);
                if (!signer) {
                    return [];
                }
                const smartAccount = await getAgwAddressFromInitialSigner(chain, transport, signer);
                return [smartAccount, signer];
            }
            case 'eth_signTypedData_v4': {
                const account = await getAgwSigner(provider);
                if (!account) {
                    throw new Error('Account not found');
                }
                if (params[0] === account) {
                    return provider.request(e);
                }
                const abstractClient = await getAgwClient(account, chain, transport, isPrivyCrossApp, overrideTransport, customPaymasterHandler);
                return abstractClient.signTypedData(JSON.parse(params[1]));
            }
            case 'personal_sign': {
                const account = await getAgwSigner(provider);
                if (!account) {
                    throw new Error('Account not found');
                }
                if (params[1] === account) {
                    return provider.request(e);
                }
                const abstractClient = await getAgwClient(account, chain, transport, isPrivyCrossApp, overrideTransport, customPaymasterHandler);
                return await abstractClient.signMessage({
                    message: {
                        raw: params[0],
                    },
                });
            }
            case 'eth_signTransaction':
            case 'eth_sendTransaction': {
                const account = await getAgwSigner(provider);
                if (!account) {
                    throw new Error('Account not found');
                }
                const transaction = params[0];
                if (transaction.from === account) {
                    return await provider.request(e);
                }
                const abstractClient = await getAgwClient(account, chain, transport, isPrivyCrossApp, overrideTransport, customPaymasterHandler);
                if (transaction.eip712Meta && transaction.eip712Meta.paymasterParams) {
                    transaction.paymaster =
                        transaction.eip712Meta.paymasterParams.paymaster;
                    transaction.paymasterInput = (0, viem_1.toHex)(transaction.eip712Meta.paymasterParams.paymasterInput);
                }
                if (method === 'eth_signTransaction') {
                    return (await abstractClient.signTransaction(transaction));
                }
                else if (method === 'eth_sendTransaction') {
                    return await abstractClient.sendTransaction(transaction);
                }
                throw new Error('Should not have reached this point');
            }
            case 'wallet_sendCalls': {
                const account = await getAgwSigner(provider);
                if (!account) {
                    throw new Error('Account not found');
                }
                const sendCallsParams = params[0];
                if (sendCallsParams.from === account) {
                    return await provider.request(e);
                }
                if (sendCallsParams.version === '1.0' ||
                    sendCallsParams.version === undefined) {
                    sendCallsParams.calls.forEach((call) => {
                        if (call.chainId) {
                            (0, viem_1.assertCurrentChain)({
                                chain,
                                currentChainId: (0, viem_1.fromHex)(call.chainId, 'number'),
                            });
                        }
                    });
                }
                if (sendCallsParams.version === '2.0.0') {
                    if ((0, viem_1.fromHex)(sendCallsParams.chainId, 'number') !== chain.id) {
                        return {
                            code: 5710,
                            message: 'Chain not supported',
                        };
                    }
                }
                const abstractClient = await getAgwClient(account, chain, transport, isPrivyCrossApp, overrideTransport, customPaymasterHandler);
                if (sendCallsParams.from !== (0, accounts_1.parseAccount)(abstractClient.account).address) {
                    return {
                        code: 4001,
                        message: 'Unauthorized',
                    };
                }
                const txHash = await abstractClient.sendTransactionBatch({
                    calls: sendCallsParams.calls.map((call) => ({
                        to: call.to,
                        value: call.value ? (0, viem_1.hexToBigInt)(call.value) : undefined,
                        data: call.data,
                    })),
                });
                if (sendCallsParams.version === undefined ||
                    sendCallsParams.version === '1.0') {
                    return txHash;
                }
                return {
                    id: txHash,
                };
            }
            case 'wallet_getCallsStatus': {
                const receipt = await provider.request({
                    method: 'eth_getTransactionReceipt',
                    params,
                });
                return {
                    version: '2.0.0',
                    id: params[0],
                    chainId: (0, viem_1.toHex)(chain.id),
                    status: (0, eip5792_js_1.getReceiptStatus)(receipt ?? undefined),
                    atomic: true,
                    receipts: receipt != null ? [receipt] : undefined,
                };
            }
            case 'wallet_addEthereumChain':
            case 'wallet_switchEthereumChain': {
                const request = params[0];
                const chainIdHex = request.chainId;
                if (!chainIdHex) {
                    throw new Error('Chain ID is required');
                }
                const chainId = (0, viem_1.isHex)(chainIdHex)
                    ? (0, viem_1.hexToNumber)(chainIdHex)
                    : chainIdHex;
                const chain = Object.values(index_js_1.validChains).find((c) => c.id === chainId);
                if (!chain) {
                    throw new Error(`Chain ${chainId} not supported`);
                }
                return await provider.request(e);
            }
            case 'wallet_showCallsStatus': {
                return undefined;
            }
            case 'wallet_getCapabilities': {
                const account = await getAgwSigner(provider);
                if (!account) {
                    throw new Error('Account not found');
                }
                if (params[0] === account) {
                    return await provider.request(e);
                }
                const chainIds = params[1];
                const capabilities = eip5792_js_1.agwCapabilitiesV2;
                if (chainIds) {
                    const filteredCapabilities = {};
                    for (const chainId of chainIds) {
                        if (capabilities[chainId]) {
                            filteredCapabilities[chainId] = capabilities[chainId];
                        }
                    }
                    return filteredCapabilities;
                }
                else {
                    return capabilities;
                }
            }
            default: {
                return await provider.request(e);
            }
        }
    };
    return {
        ...provider,
        on: provider.on,
        removeListener: provider.removeListener,
        request: handler,
    };
}
//# sourceMappingURL=transformEIP1193Provider.js.map