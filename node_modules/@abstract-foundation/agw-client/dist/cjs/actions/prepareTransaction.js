"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MaxFeePerGasTooLowError = exports.defaultParameters = void 0;
exports.prepareTransactionRequest = prepareTransactionRequest;
const viem_1 = require("viem");
const actions_1 = require("viem/actions");
const utils_1 = require("viem/utils");
const zksync_1 = require("viem/zksync");
const constants_js_1 = require("../constants.js");
const insufficientBalance_js_1 = require("../errors/insufficientBalance.js");
const constants_js_2 = require("../exports/constants.js");
const utils_js_1 = require("../utils.js");
const utils_js_2 = require("../utils.js");
exports.defaultParameters = [
    'blobVersionedHashes',
    'chainId',
    'fees',
    'gas',
    'nonce',
    'type',
];
class MaxFeePerGasTooLowError extends viem_1.BaseError {
    constructor({ maxPriorityFeePerGas }) {
        super(`\`maxFeePerGas\` cannot be less than the \`maxPriorityFeePerGas\` (${(0, viem_1.formatGwei)(maxPriorityFeePerGas)} gwei).`, { name: 'MaxFeePerGasTooLowError' });
    }
}
exports.MaxFeePerGasTooLowError = MaxFeePerGasTooLowError;
async function prepareTransactionRequest(client, signerClient, publicClient, args) {
    (0, utils_js_1.transformHexValues)(args, [
        'value',
        'nonce',
        'maxFeePerGas',
        'maxPriorityFeePerGas',
        'gas',
        'chainId',
        'gasPerPubdata',
    ]);
    const isSponsored = 'paymaster' in args &&
        'paymasterInput' in args &&
        args.paymaster !== undefined &&
        args.paymasterInput !== undefined;
    const { gas, nonce, chain, nonceManager, parameters: parameterNames = exports.defaultParameters, } = args;
    const isDeployed = await (0, utils_js_1.isSmartAccountDeployed)(publicClient, client.account.address);
    if (!isDeployed) {
        const initialCall = {
            target: args.to,
            allowFailure: false,
            value: args.value ?? 0,
            callData: args.data ?? '0x',
        };
        const initializerCallData = (0, utils_js_2.getInitializerCalldata)(signerClient.account.address, constants_js_1.EOA_VALIDATOR_ADDRESS, initialCall);
        const addressBytes = (0, viem_1.toBytes)(signerClient.account.address);
        const salt = (0, viem_1.keccak256)(addressBytes);
        const deploymentCalldata = (0, viem_1.encodeFunctionData)({
            abi: constants_js_2.AccountFactoryAbi,
            functionName: 'deployAccount',
            args: [salt, initializerCallData],
        });
        args.to = constants_js_1.SMART_ACCOUNT_FACTORY_ADDRESS;
        args.data = deploymentCalldata;
    }
    const initiatorAccount = (0, utils_1.parseAccount)(isDeployed ? client.account : signerClient.account);
    const request = {
        ...args,
        from: initiatorAccount.address,
    };
    const asyncOperations = [];
    let userBalance;
    if (!isSponsored || (request.value !== undefined && request.value > 0n)) {
        asyncOperations.push((0, actions_1.getBalance)(publicClient, {
            address: initiatorAccount.address,
        }).then((balance) => {
            userBalance = balance;
        }));
    }
    let chainId;
    async function getChainId() {
        if (chainId)
            return chainId;
        if (chain)
            return chain.id;
        if (typeof args.chainId !== 'undefined')
            return args.chainId;
        const chainId_ = await (0, utils_1.getAction)(client, actions_1.getChainId, 'getChainId')({});
        chainId = chainId_;
        return chainId;
    }
    if (parameterNames.includes('nonce') &&
        typeof nonce === 'undefined' &&
        initiatorAccount) {
        if (nonceManager) {
            asyncOperations.push((async () => {
                const chainId = await getChainId();
                request.nonce = await nonceManager.consume({
                    address: initiatorAccount.address,
                    chainId,
                    client: publicClient,
                });
            })());
        }
        else {
            asyncOperations.push((0, utils_1.getAction)(publicClient, actions_1.getTransactionCount, 'getTransactionCount')({
                address: initiatorAccount.address,
                blockTag: 'pending',
            }).then((nonce) => {
                request.nonce = nonce;
            }));
        }
    }
    let gasLimitFromFeeEstimation;
    if (parameterNames.includes('fees')) {
        if (typeof request.maxFeePerGas === 'undefined' ||
            typeof request.maxPriorityFeePerGas === 'undefined') {
            asyncOperations.push((async () => {
                let maxFeePerGas;
                let maxPriorityFeePerGas;
                if (request.to === constants_js_1.CONTRACT_DEPLOYER_ADDRESS) {
                    maxFeePerGas = 25000000n;
                    maxPriorityFeePerGas = 0n;
                }
                else {
                    const estimateFeeRequest = {
                        account: initiatorAccount,
                        to: request.to,
                        value: request.value,
                        data: request.data,
                        gas: request.gas,
                        nonce: request.nonce,
                        chainId: request.chainId,
                        authorizationList: [],
                    };
                    let feeEstimation;
                    try {
                        feeEstimation = await (0, zksync_1.estimateFee)(publicClient, estimateFeeRequest);
                    }
                    catch (error) {
                        if (error instanceof Error &&
                            error.message.includes(constants_js_1.INSUFFICIENT_BALANCE_SELECTOR)) {
                            throw new insufficientBalance_js_1.InsufficientBalanceError();
                        }
                        else if (error instanceof viem_1.RpcRequestError &&
                            error.details.includes('execution reverted')) {
                            throw new viem_1.ExecutionRevertedError({
                                message: `${error.data}`,
                            });
                        }
                        throw error;
                    }
                    maxFeePerGas = feeEstimation.maxFeePerGas;
                    maxPriorityFeePerGas = feeEstimation.maxPriorityFeePerGas;
                    gasLimitFromFeeEstimation = feeEstimation.gasLimit;
                }
                if (typeof args.maxPriorityFeePerGas === 'undefined' &&
                    args.maxFeePerGas &&
                    args.maxFeePerGas < maxPriorityFeePerGas)
                    throw new MaxFeePerGasTooLowError({
                        maxPriorityFeePerGas,
                    });
                request.maxPriorityFeePerGas = maxPriorityFeePerGas;
                request.maxFeePerGas = maxFeePerGas;
                if (typeof gas === 'undefined') {
                    request.gas = gasLimitFromFeeEstimation;
                }
            })());
        }
    }
    await Promise.all(asyncOperations);
    const gasCost = isSponsored || !request.gas || !request.maxFeePerGas
        ? 0n
        : request.gas * request.maxFeePerGas;
    if (userBalance !== undefined &&
        userBalance < (request.value ?? 0n) + gasCost) {
        throw new insufficientBalance_js_1.InsufficientBalanceError();
    }
    if (parameterNames.includes('gas') &&
        typeof gas === 'undefined' &&
        gasLimitFromFeeEstimation === undefined) {
        request.gas = await (0, utils_1.getAction)(client, actions_1.estimateGas, 'estimateGas')({
            ...request,
            account: initiatorAccount
                ? { address: initiatorAccount.address, type: 'json-rpc' }
                : undefined,
        });
    }
    (0, utils_1.assertRequest)(request);
    delete request.parameters;
    delete request.isInitialTransaction;
    delete request.nonceManager;
    return request;
}
//# sourceMappingURL=prepareTransaction.js.map