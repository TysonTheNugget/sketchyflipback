"use strict";var e=require("@wagmi/core"),t=require("viem"),n=require("./provider.js");require("./client.js"),require("./getCrossAppProviderDetails.js"),require("./request.js"),require("./crypto.js"),require("@noble/curves/secp256k1"),require("@scure/base"),require("buffer"),require("fflate"),require("./triggerPopup.js"),require("./sendConnectionRequestToPopup.js"),require("./storage.js"),exports.toPrivyWalletConnector=function(i,r){let o,a,s,c,h=null;return e.createConnector((d=>({id:i.id,name:i.name,icon:i.iconUrl,type:"privy",...r,isWalletConnectModalConnector:!1,async setup(){let e=await this.getProvider();e&&(s||(s=this.onConnect.bind(this),e.on("connect",s)),o||(o=this.onAccountsChanged.bind(this),e.on("accountsChanged",o)))},async connect(e){let t=await this.getProvider();if(t&&await this.isAuthorized()){let[e,t]=await Promise.all([this.getAccounts(),this.getChainId()]);return{accounts:e,chainId:t}}if(e?.isReconnecting)return{accounts:[],chainId:1};await t.request({method:"eth_requestAccounts"}),s&&(t.removeListener("connect",s),s=void 0),o||(o=this.onAccountsChanged.bind(this),t.on("accountsChanged",o)),a||(a=this.onChainChanged.bind(this),t.on("chainChanged",a)),c||(c=this.onDisconnect.bind(this),t.on("disconnect",c)),e?.chainId&&await this.switchChain({chainId:e.chainId});let[n,i]=await Promise.all([this.getAccounts(),this.getChainId()]);return{accounts:n,chainId:i}},async disconnect(){let e=await this.getProvider();a&&(e.removeListener("chainChanged",a),a=void 0),c&&(e.removeListener("disconnect",c),c=void 0),s||(s=this.onConnect.bind(this),e.on("connect",s)),await e.request({method:"wallet_revokePermissions",params:[{eth_accounts:{}}]}),this.onDisconnect()},async getAccounts(){let n=await this.getProvider();if(!n)throw new e.ProviderNotFoundError;return(await n.request({method:"eth_accounts"})).map((e=>t.getAddress(e)))},async getChainId(){let t=await this.getProvider();if(!t)throw new e.ProviderNotFoundError;return Number(await t.request({method:"eth_chainId"}))},getProvider:async()=>(h||(h=n.toPrivyWalletProvider({chains:d.chains,transports:d.transports,providerAppId:i.id,apiUrl:i.apiUrl,smartWalletMode:i.smartWalletMode})),h),async isAuthorized(){try{return!!(await this.getAccounts()).length}catch(e){return!1}},async switchChain({chainId:n}){let i=await this.getProvider();if(!i)throw new e.ProviderNotFoundError;let r=d.chains.find((e=>e.id===n));if(!r)throw new t.SwitchChainError(new e.ChainNotConfiguredError);return n===Number(await i.request({method:"eth_chainId"}))||(await i.request({method:"wallet_switchEthereumChain",params:[{chainId:`0x${n.toString(16)}`}]}),d.emitter.emit("change",{chainId:n})),r},async onAccountsChanged(e){if(0!==e.length)if(d.emitter.listenerCount("connect")){let e=(await this.getChainId()).toString();this.onConnect?.({chainId:e})}else d.emitter.emit("change",{accounts:e.map((e=>t.getAddress(e)))});else this.onDisconnect()},onChainChanged(e){let t=Number(e);d.emitter.emit("change",{chainId:t})},async onConnect(e){let t=await this.getAccounts();if(0===t.length)return;let n=Number(e.chainId);d.emitter.emit("connect",{accounts:t,chainId:n});let i=await this.getProvider();i&&(s&&(i.removeListener("connect",s),s=void 0),o||(o=this.onAccountsChanged.bind(this),i.on("accountsChanged",o)),a||(a=this.onChainChanged.bind(this),i.on("chainChanged",a)),c||(c=this.onDisconnect.bind(this),i.on("disconnect",c)))},async onDisconnect(){d.emitter.emit("disconnect")}})))};
