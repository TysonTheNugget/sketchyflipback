"use strict";var e=require("@noble/curves/secp256k1"),r=require("@scure/base"),t=require("buffer"),c=require("fflate");exports.decryptResult=async function({encryptedResult:e,iv:n,sharedSecret:a}){let s=r.base64.decode(a),o=r.base64.decode(n),i=await crypto.subtle.importKey("raw",s,{name:"AES-GCM"},!0,["decrypt"]),d=r.base64.decode(e),u=await crypto.subtle.decrypt({name:"AES-GCM",iv:o},i,d),y=c.unzlibSync(t.Buffer.from(u));return(new TextDecoder).decode(y)},exports.encryptRequest=async function(e,t){let n=JSON.stringify(e),a=c.zlibSync((new TextEncoder).encode(n)),s=r.base64.decode(t),o=await crypto.subtle.importKey("raw",s,{name:"AES-GCM"},!0,["encrypt"]),i=crypto.getRandomValues(new Uint8Array(12)),d=await crypto.subtle.encrypt({name:"AES-GCM",iv:i},o,a);return{iv:r.base64.encode(i),encryptedRequest:r.base64.encode(new Uint8Array(d))}},exports.generateKeyPair=function(){let t=e.secp256k1.utils.randomPrivateKey(),c=e.secp256k1.getPublicKey(t);return{privateKey:r.base64.encode(t),publicKey:r.base64.encode(c)}},exports.recoverSharedSecret=function({privateKey:t,publicKey:c}){let n=e.secp256k1.getSharedSecret(r.base64.decode(t),r.base64.decode(c)).slice(1);return r.base64.encode(n)};
