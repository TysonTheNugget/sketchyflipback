import{secp256k1 as e}from"@noble/curves/secp256k1";import{base64 as t}from"@scure/base";import{Buffer as r}from"buffer";import{zlibSync as c,unzlibSync as n}from"fflate";function o(){let r=e.utils.randomPrivateKey(),c=e.getPublicKey(r);return{privateKey:t.encode(r),publicKey:t.encode(c)}}function d({privateKey:r,publicKey:c}){let n=e.getSharedSecret(t.decode(r),t.decode(c)).slice(1);return t.encode(n)}async function i(e,r){let n=JSON.stringify(e),o=c((new TextEncoder).encode(n)),d=t.decode(r),i=await crypto.subtle.importKey("raw",d,{name:"AES-GCM"},!0,["encrypt"]),a=crypto.getRandomValues(new Uint8Array(12)),y=await crypto.subtle.encrypt({name:"AES-GCM",iv:a},i,o);return{iv:t.encode(a),encryptedRequest:t.encode(new Uint8Array(y))}}async function a({encryptedResult:e,iv:c,sharedSecret:o}){let d=t.decode(o),i=t.decode(c),a=await crypto.subtle.importKey("raw",d,{name:"AES-GCM"},!0,["decrypt"]),y=t.decode(e),p=await crypto.subtle.decrypt({name:"AES-GCM",iv:i},a,y),u=n(r.from(p));return(new TextDecoder).decode(u)}export{a as decryptResult,i as encryptRequest,o as generateKeyPair,d as recoverSharedSecret};
