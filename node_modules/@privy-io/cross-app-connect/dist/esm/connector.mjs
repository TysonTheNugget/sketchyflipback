import{createConnector as t,ProviderNotFoundError as e,ChainNotConfiguredError as n}from"@wagmi/core";import{getAddress as i,SwitchChainError as o}from"viem";import{toPrivyWalletProvider as a}from"./provider.mjs";import"./client.mjs";import"./getCrossAppProviderDetails.mjs";import"./request.mjs";import"./crypto.mjs";import"@noble/curves/secp256k1";import"@scure/base";import"buffer";import"fflate";import"./triggerPopup.mjs";import"./sendConnectionRequestToPopup.mjs";import"./storage.mjs";function s(s,c){let r,h,d,m,u=null;return t((t=>({id:s.id,name:s.name,icon:s.iconUrl,type:"privy",...c,isWalletConnectModalConnector:!1,async setup(){let t=await this.getProvider();t&&(d||(d=this.onConnect.bind(this),t.on("connect",d)),r||(r=this.onAccountsChanged.bind(this),t.on("accountsChanged",r)))},async connect(t){let e=await this.getProvider();if(e&&await this.isAuthorized()){let[t,e]=await Promise.all([this.getAccounts(),this.getChainId()]);return{accounts:t,chainId:e}}if(t?.isReconnecting)return{accounts:[],chainId:1};await e.request({method:"eth_requestAccounts"}),d&&(e.removeListener("connect",d),d=void 0),r||(r=this.onAccountsChanged.bind(this),e.on("accountsChanged",r)),h||(h=this.onChainChanged.bind(this),e.on("chainChanged",h)),m||(m=this.onDisconnect.bind(this),e.on("disconnect",m)),t?.chainId&&await this.switchChain({chainId:t.chainId});let[n,i]=await Promise.all([this.getAccounts(),this.getChainId()]);return{accounts:n,chainId:i}},async disconnect(){let t=await this.getProvider();h&&(t.removeListener("chainChanged",h),h=void 0),m&&(t.removeListener("disconnect",m),m=void 0),d||(d=this.onConnect.bind(this),t.on("connect",d)),await t.request({method:"wallet_revokePermissions",params:[{eth_accounts:{}}]}),this.onDisconnect()},async getAccounts(){let t=await this.getProvider();if(!t)throw new e;return(await t.request({method:"eth_accounts"})).map((t=>i(t)))},async getChainId(){let t=await this.getProvider();if(!t)throw new e;return Number(await t.request({method:"eth_chainId"}))},getProvider:async()=>(u||(u=a({chains:t.chains,transports:t.transports,providerAppId:s.id,apiUrl:s.apiUrl,smartWalletMode:s.smartWalletMode})),u),async isAuthorized(){try{return!!(await this.getAccounts()).length}catch(t){return!1}},async switchChain({chainId:i}){let a=await this.getProvider();if(!a)throw new e;let s=t.chains.find((t=>t.id===i));if(!s)throw new o(new n);return i===Number(await a.request({method:"eth_chainId"}))||(await a.request({method:"wallet_switchEthereumChain",params:[{chainId:`0x${i.toString(16)}`}]}),t.emitter.emit("change",{chainId:i})),s},async onAccountsChanged(e){if(0!==e.length)if(t.emitter.listenerCount("connect")){let t=(await this.getChainId()).toString();this.onConnect?.({chainId:t})}else t.emitter.emit("change",{accounts:e.map((t=>i(t)))});else this.onDisconnect()},onChainChanged(e){let n=Number(e);t.emitter.emit("change",{chainId:n})},async onConnect(e){let n=await this.getAccounts();if(0===n.length)return;let i=Number(e.chainId);t.emitter.emit("connect",{accounts:n,chainId:i});let o=await this.getProvider();o&&(d&&(o.removeListener("connect",d),d=void 0),r||(r=this.onAccountsChanged.bind(this),o.on("accountsChanged",r)),h||(h=this.onChainChanged.bind(this),o.on("chainChanged",h)),m||(m=this.onDisconnect.bind(this),o.on("disconnect",m)))},async onDisconnect(){t.emitter.emit("disconnect")}})))}export{s as toPrivyWalletConnector};
